// 陷阱处理的公共定义
#ifndef JOS_INC_TRAP_H
#define JOS_INC_TRAP_H

// 中断向量
// 这些是由CPU定义的:
#define T_DIVIDE     0		// 0.除零错误
#define T_DEBUG      1		// 1.调试异常
#define T_NMI        2		// 2.不可屏蔽中断
#define T_BRKPT      3		// 3.断点(一个字节的INT3指令)
#define T_OFLOW      4		// 4.溢出(INTO指令)
#define T_BOUND      5		// 5.边界检验(BOUND指令)
#define T_ILLOP      6		// 6.非法操作符
#define T_DEVICE     7		// 7.设备不可用
#define T_DBLFLT     8		// 8.双重错误
/* #define T_COPROC  9 */	// reserved (not generated by recent processors)
#define T_TSS       10		// 10.无效的TSS
#define T_SEGNP     11		// 11.段不存在
#define T_STACK     12		// 12.栈异常
#define T_GPFLT     13		// 13.通用保护
#define T_PGFLT     14		// 14.页错误
/* #define T_RES    15 */	// reserved
#define T_FPERR     16		// 16.x87FPU 浮点错误
#define T_ALIGN     17		// 17.界限检查
#define T_MCHK      18		// 18.机器检查
#define T_SIMDERR   19		// 19.SIMD 浮点错误

// These are arbitrarily chosen, but with care not to overlap
// processor defined exceptions or interrupt vectors.
#define T_SYSCALL   48		// 48.系统调用
#define T_DEFAULT   500		// catchall

#define IRQ_OFFSET	32	// IRQ 0 corresponds to int IRQ_OFFSET

// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)
#define IRQ_TIMER        0
#define IRQ_KBD          1
#define IRQ_SERIAL       4
#define IRQ_SPURIOUS     7
#define IRQ_IDE         14
#define IRQ_ERROR       19

#ifndef __ASSEMBLER__

#include <inc/types.h>

// 声明中断异常处理函数名
void t_divide();
void t_debug();
void t_nmi();    
void t_brkpt(); 
void t_oflow();
void t_bound();
void t_illop();
void t_device();
void t_dblflt();
// reserved
void t_tss();
void t_segnp();
void t_stack();
void t_gpflt();
void t_pgflt();
// reserved
void t_fperr();
void t_align();
void t_mchk();
void t_simderr();
void t_syscall();

struct PushRegs {
	/* pushal 指令就能把以下所有寄存器压栈 */
	uint32_t reg_edi;
	uint32_t reg_esi;
	uint32_t reg_ebp;
	uint32_t reg_oesp;		/* 无效的寄存器 */
	uint32_t reg_ebx;
	uint32_t reg_edx;
	uint32_t reg_ecx;
	uint32_t reg_eax;
} __attribute__((packed));	// 使编译器取消结构体在编译过程中的优化对齐,按照实际占用字节数进行对齐

// 当环境不运行时被保存的环境帧(用户环境关键的寄存器值)，主要用于上下文切换，由栈特性，该结构寄存器压栈由下往上，出栈从上至下
// EFLAGS:状态寄存器，EIP:指令指针，ESP:栈指针(栈顶地址)，EBP:当前环境帧在栈中的开始地址(高地址)，即栈[EBP,ESP]存储的就是环境帧
// padding: 段寄存器只有16位，为了补足栈帧规定的32位
struct Trapframe {
	struct PushRegs tf_regs;
	uint16_t tf_es;
	uint16_t tf_padding1;
	uint16_t tf_ds;
	uint16_t tf_padding2;
	// 中断向量
	uint32_t tf_trapno;
	/* 以下的寄存器由 x86 架构硬件定义 */
	// error code
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;
	/* 以下的寄存器是只有环境跳转才会压栈，例如从用户态到内核态 */
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding4;
} __attribute__((packed));	// 使编译器取消结构体在编译过程中的优化对齐,按照实际占用字节数进行对齐


#endif /* !__ASSEMBLER__ */

#endif /* !JOS_INC_TRAP_H */
